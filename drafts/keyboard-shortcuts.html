<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" href="styles.css" />
        <title>Stop Teaching People Git - Artificially Intelligent</title>
        <script>
            !function(t,e){var o,n,p,r;e.__SV||(window.posthog=e,e._i=[],e.init=function(i,s,a){function g(t,e){var o=e.split(".");2==o.length&&(t=t[o[0]],e=o[1]),t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}}(p=t.createElement("script")).type="text/javascript",p.crossOrigin="anonymous",p.async=!0,p.src=s.api_host.replace(".i.posthog.com","-assets.i.posthog.com")+"/static/array.js",(r=t.getElementsByTagName("script")[0]).parentNode.insertBefore(p,r);var u=e;for(void 0!==a?u=e[a]=[]:a="posthog",u.people=u.people||[],u.toString=function(t){var e="posthog";return"posthog"!==a&&(e+="."+a),t||(e+=" (stub)"),e},u.people.toString=function(){return u.toString(1)+".people (stub)"},o="init Ce Os As Te Cs Fs capture Ye calculateEventProperties Ls register register_once register_for_session unregister unregister_for_session qs getFeatureFlag getFeatureFlagPayload isFeatureEnabled reloadFeatureFlags updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures on onFeatureFlags onSurveysLoaded onSessionId getSurveys getActiveMatchingSurveys renderSurvey canRenderSurvey canRenderSurveyAsync identify setPersonProperties group resetGroups setPersonPropertiesForFlags resetPersonPropertiesForFlags setGroupPropertiesForFlags resetGroupPropertiesForFlags reset get_distinct_id getGroups get_session_id get_session_replay_url alias set_config startSessionRecording stopSessionRecording sessionRecordingStarted captureException loadToolbar get_property getSessionProperty zs js createPersonProfile Us Rs Bs opt_in_capturing opt_out_capturing has_opted_in_capturing has_opted_out_capturing get_explicit_consent_status is_capturing clear_opt_in_out_capturing Ds debug L Ns getPageViewId captureTraceFeedback captureTraceMetric".split(" "),n=0;n<o.length;n++)g(u,o[n]);e._i.push([i,s,a])},e.__SV=1)}(document,window.posthog||[]);
            posthog.init('phc_cca9KKKjIkYHqpKIZZjPheubHG1m8QmZ9bOOOyQU51G', {
                api_host: 'https://eu.i.posthog.com',
                defaults: '2025-05-24',
                person_profiles: 'identified_only', // or 'always' to create profiles for anonymous users as well
            })
        </script>
    </head>
    <body>
        <header>
            <h1>Artificially Intelligent</h1>
        </header>

        <main>
            <article>
                <h2>Stop Teaching People Git</h2>
                <p><em>Published: April 28, 2025 | Category: Complaining With Authority</em></p>

                <p>I used to love the idea of keyboard shortcuts in applications.
                Now I'm not so sure.</p>

                <p>These reflections began after a forgetful moment, I recently found myself without my mouse.
                I also use a laptop stand to combat my gradual evolution morphing of my spine in to a C.
                Thus my trackpad is elevated up and away from my hands.
                So faced with my trackpad now being super awkward to use, I was faced with a choice.
                I could briefly put my laptop down on the desk and use it like pretty much everyone else.
                Or, <em>or</em> I could simply stop using a mouse and like the ultra-elite hack3rs of yore, use my keyboard for everything.
                I would move through the digital realms with absolute speed and precision.</p>

                <p>Here's the problem with this approach.
                It sucks.
                When you try and tack on a keyboard-only approach for <em>everything</em>, you become acutely aware of just how much we rely on a mouse as the default tool for intuitively interacting with a myriad of things.
                The thing is there.
                I move the mouse to the thing.
                I click.
                Interaction.</p>

                <p>But the keyboard is different.
                It requires knowledge ahead of time about how what you do on the keyboard in order to interact with an interface.</p>

                <p>And this is <em>much</em> harder to get right, both from a design perspective and what you, as a user, are required to do.
                Now at the risk of sounding like a twat, this experience has given me a slim insight in to what it might feel like to have some sort of restriction when interacting with interfaces built for the majority, and other interactions as an afterthought, or add-on.
                I'm (probably) not mentioning this in order to up my creds, but instead, just to just mention an appreciation.
                Folks who think about accessibility and properly give interfaces a think, benefit the rest of us.
                So on the off chance that someone who does this work actually reads this - thanks.</p>

                <p>Have you tried switching between Jupyter notebooks and Elixir livebooks?
                Good luck.
                There are other ways that you can</p>

                <p>Here's a rule of thumb I think I could possibly profer to the universe in exchange for letting me whine about my tiny problems for 200 words.
                (I retain the right to update this if upon relfection this feels less wise in 2 weeks time.)</p>

                <p>If you're not going to be in the top 5 most used applications for a user, then you probably shouldn't bother coming up with keyboard shortcuts.
                If you have a slim margin of power users who pester you for a keyboard interface (<em>sideye at the Vim community</em>), maybe make that optional.</p>

                <h3>Keyboard shortcuts that make sense to support</h3>

                <p><code>cmd - F</code>: Let me search. (Once those search options come up, let me use my fucking keyboard to interact with the results). However, if you're a developer, then messing with cmd-f means that you override the built-in functionality to find text anywhere on the page, which is provided by the browser. So if you're not working in-browser, I think<br>
                <code>cmd - enter/return</code>: we're in slightly shakier ground here - in some cases this puts you on a newline, and in other cases is submit. Please folks, let's sort this out and just do the same thing?<br>
                <code>shift - enter</code>: same as above.<br>
                <code>cmd - k</code>: you can do lots of things. But then this often clashes with the code editor convention of <code>cmd+shift+p</code><br>
                ...</p>

                <h3>Machine Keyboard conventions:</h3>

                <p>For my sins, I have been a mac user for the past 13 years.
                In that time, the ways to navigate text have become second nature.
                Part of the reason for this is that this <em>always</em> works.</p>

                <p><code>cmd - ←</code>: Go to the start of the line<br>
                <code>cmd - →</code>: Go to the end of the line<br>
                <code>cmd - ↑</code>: Go to the top of the page<br>
                <code>cmd - ↓</code>: Go to the bottom of the page</p>

                <p>I think my main gripe here is that when you're thinking about power users, and you start to design for them, if the "speedsups" for them start to bleed over to your average user, then you've gone too far and you need to dial it back.
                Please remember that <em>if you are the designer of the thing, then you are not the average or median user</em>.</p>

                <p>I think it's probably also worth thinking about how long a user would spend in your interface, not in total, but the duration of times that a user spends in your application.
                In other words, if I'm constantly dropping in your app and then spiriting myself away again to do something else, then the</p>

                <p>Scrolling. Please. Just give me a way to scroll with my keyboard.</p>

                <p>This is perhaps one reason why I am levitating away from native apps and instead back to web-apps of various apps.
                Browser apps like vimium give me a consistent way to navigate around various interfaces.
                Default apps vary wildly in their consistency with navigating with a keyboard.</p>

                <p>You might be thinking, but ArtificiallyInteligent, you just don't have the right <em>setup</em>.
                And you might be right, <em>if</em> you're not taking in to account the time it takes to get used to that setup.
                I have not switched to vim for that very reason, but it is the one convention that seems to have made it's way to other tools, so if I do end up going deeper down the rabbit hole, this is the most likely path.</p>

                <h2>Keyboard interactions that I just want to whinge about</h2>
                <p>In the Spotify app, when you want to search for a song (and that's the only thing that you'd want <em>can</em> do in the search bar) - then you don't go cmd+f, you have to do cmd+k
                In apps like Slack and Linear, this activates the command bar, where you  can do a number of actions.
                However, because the <em>only</em> thing you're doing is searching, why would you let them do anything else?</p>
            </article>
        </main>

        <footer>
            <p>&copy; 2025 Artificially Intelligent</p>
        </footer>
    </body>
</html>
